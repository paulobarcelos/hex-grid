
<link rel="import" href="../polymer/polymer.html">

<dom-module id="hex-grid">
	<template>
		<style>
			:host {
				display: block;
				box-sizing: border-box;
				overflow: scroll;

			}
			#container ::content > .item{
				position: absolute;
				overflow: hidden;
				box-sizing: border-box;
			}
			#container ::content > .item .outer,
			#container ::content > .item .inner{
				position: absolute;
				overflow: hidden;
				box-sizing: border-box;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
			#container ::content > .item .inner{
				-webkit-clip-path: polygon(
					25% 0%,
					75% 0%,
					100% 50%,
					75% 100%,
					25% 100%,
					0% 50%,
					25% 0%
				);
			}
			#container ::content > .item .outer{
				transition: transform 0.4s ease-in-out,	 opacity 0.5s ease-out;
				transform: scale(0.999,0.999,0);
				opacity: 0.999;
			}
			#container ::content > .item.removed .outer{
				opacity: 0;
			}
			#container ::content > .item.out .outer{
				transform: scale3d(0,0,0);
			}

		</style>

		<div id="container">
			<content id="content" select=".item"></content>
		</div>

	</template>
</dom-module>

<script>

	Polymer({

		is: 'hex-grid',

		properties: {
			size: {
				type: Number
			},
			margin:{
				type: Number
			},
			fitting: {
				type: Number
			},
			minScale: {
				type: Number
			},
			dropChance: {
				type: Number,
			},
			reviveChance: {
				type: Number,
			},
			dropInterval: {
				type: Number,
			},
			items:{
				type: Array,
				value: []
			}
		},
		attached: function(){
			this._layout();
		},
		listeners:{
			'scroll': '_onScroll'
		},
		observers:[
			'_layout(size, fitting, minScale, margin)'
		],
		ready: function(){
			var observer = new MutationObserver(this._layout.bind(this));
			observer.observe(this, {
				childList: true,
				subtree: true,
				characterData: true
			});

			this._rootFontSize = parseFloat(getComputedStyle(document.documentElement).fontSize);
			this._render();
		},
		_layout: function(){
			var boundingRect = this.getBoundingClientRect();
			this._windowWidth = parseFloat(boundingRect.width / this._rootFontSize);
			this._windowHeight = parseFloat(boundingRect.height / this._rootFontSize);

			this.items = Polymer.dom(this.$.content).getDistributedNodes();
			if(!this.items.length){
				return;
			}
			var rows = Math.floor(Math.sqrt(this.items.length));
			var cols = Math.ceil(this.items.length / rows);

			var width = this.size * 2;
			var height = Math.sqrt(3)/2 * width;
			var horizontalSpace = width * 3/4;
			var verticalSpace = height;
			for (var x = 0; x < cols; x++) {
				for (var y = 0; y < rows; y++) {
					var index = (y*cols) + x;
					var item = this.items[index];
					if(index >= this.items.length){
						continue;
					}
					item.dataset.xIndex = x;
					item.dataset.yIndex = y;
					item.dataset.index = index;

					item.dataset.width = (width * this.fitting);
					item.dataset.height = (height * this.fitting);
					item.dataset.top = this.margin + (y * verticalSpace + (x % 2) * height / 2);
					item.dataset.left = this.margin + (x * horizontalSpace);

					item.style.width = item.dataset.width + 'rem';
					item.style.height = item.dataset.height + 'rem';
					item.style.top = item.dataset.top + 'rem';
					item.style.left = item.dataset.left + 'rem';

				}
			}
			var containerHeight = ((cols - 1) * horizontalSpace + (width * 1-(3/4) ) * this.fitting)+ this.margin * 2;
			var containerWidth = (verticalSpace * rows + verticalSpace / 2 - verticalSpace * (1-this.fitting)) +  this.margin * 2;
			this.$.container.style.width = containerHeight + 'rem';
			this.$.container.style.height = containerWidth + 'rem';
			//this.translated3d( this.margin  + 'rem',  this.margin  + 'rem', 0, this.$.container);
			//this.scrollTop = (containerHeight * this._rootFontSize - boundingRect.height) * 0.37;
			//this.scrollLeft = (containerWidth * this._rootFontSize - boundingRect.width) * 0.37;
			//this._onScroll();


			var removeItems = function(){
				this.items.forEach(function(item) {
					if(Math.random() > 1 - this.dropChance){
						item.classList.add('removed');
					}
				}.bind(this));
				this.items.forEach(function(item) {
					if(Math.random() > 1 - this.reviveChance){
						item.classList.remove('removed');
					}
				}.bind(this));
				this.debounce('removeItems', removeItems, this.dropInterval);
			}.bind(this);
			this.cancelDebouncer('removeItems');
			this.debounce('removeItems', removeItems, this.dropInterval);
		},
		_onScroll: function(){
			this._normalizedScrollTop = this.scrollTop / this._rootFontSize;
			this._normalizedScrollLeft =  this.scrollLeft / this._rootFontSize;
		},
		_render: function(){
			this.items.forEach(function(item) {
				var distL = this._normalizedScrollLeft  - item.dataset.left;
				var percentL = distL / item.dataset.width;

				var distT = this._normalizedScrollTop - item.dataset.top;
				var percentT = distT / item.dataset.height;

				var distB = parseFloat(item.dataset.top) + parseFloat(item.dataset.height) - (this._normalizedScrollTop + this._windowHeight);
				var percentB = distB / item.dataset.height;

				var distR = parseFloat(item.dataset.left) + parseFloat(item.dataset.width) - (this._normalizedScrollLeft  + this._windowWidth);
				var percentR = distR / item.dataset.width;

				var biggestPercent = percentL;
				if(percentR > biggestPercent){
					biggestPercent = percentR;
				}
				if(percentB > biggestPercent){
					biggestPercent = percentB;
				}
				if(percentT > biggestPercent){
					biggestPercent = percentT;
				}

				var transformOriginLeft = '50%';
				var transformOriginTop = '50%';
				var scaleAdjust
				/*if(percentL > 0){
					transformOriginLeft = '100%';
					transformOriginTop = '50%';
					if(percentT > 0){
						transformOriginLeft = '85%';
						transformOriginTop = '75%';
					}
					else if(percentB > 0){
						transformOriginLeft = '85%';
						transformOriginTop = '25%';
					}
				}
				else if(percentR > 0){
					transformOriginLeft = '0%';
					transformOriginTop = '50%';
					if(percentT > 0){
						transformOriginLeft = '15%';
						transformOriginTop = '75%';
					}
					else if(percentB > 0){
						transformOriginLeft = '15%';
						transformOriginTop = '25%';
					}
				}
				else if(percentT > 0){
					transformOriginLeft = '50%';
					transformOriginTop = '100%';
				}
				else if(percentB > 0){
					transformOriginLeft = '50%';
					transformOriginTop = '0%';
				}*/
				if(percentL > 0){
					transformOriginLeft = '100%';
					transformOriginTop = '50%';

				}
				if(percentR > 0){
					transformOriginLeft = '0%';
					transformOriginTop = '50%';
				}
				if(percentT > 0){
					transformOriginLeft = '50%';
					transformOriginTop = '100%';

				}
				if(percentB > 0){
					transformOriginLeft = '50%';
					transformOriginTop = '0%';
				}

				/*if(percentL > 0 && percentT > 0){
					transformOriginLeft = '0%';
					transformOriginTop = '0%';
				}
				if(percentL > 0 && percentB > 0){
					transformOriginLeft = '0%';
					transformOriginTop = '100%';
				}
				if(percentR > 0 && percentT > 0){
					transformOriginLeft = '100%';
					transformOriginTop = '0%';
				}
				*/
				if(	(percentR > 0 && percentB > 0) ||
					(percentR > 0 && percentT > 0) ||
					(percentL > 0 && percentT > 0) ||
					(percentL > 0 && percentB > 0)){
					item.classList.add('out');
				}
				else{
					item.classList.remove('out');
				}

				var debug = item.querySelector('.debug');
				//debug.innerHTML = percentT + ' ' +percentR + ' '+percentB + ' '+percentL ;



				var scale = 1;
				if(biggestPercent > 0 && biggestPercent < 1){
					scale = 1 - biggestPercent;
				}
				var opacity = 1;
				if(scale < this.minScale){
					opacity = Math.pow(scale / this.minScale,3);
				}
				item.style.opacity = opacity;
				item.style.transformOrigin = transformOriginLeft + ' ' + transformOriginTop;
				this.transform('scale3d('+scale+','+scale+',1)', item);

			}.bind(this));

			window.requestAnimationFrame(this._render.bind(this));

		}

	});

</script>
